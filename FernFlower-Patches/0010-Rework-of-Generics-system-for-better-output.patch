From e9c3ec6111ba05aeddcc6a8729bbaf3633fd52de Mon Sep 17 00:00:00 2001
From: LexManos <LexManos@gmail.com>
Date: Fri, 14 Apr 2017 17:09:41 -0700
Subject: [PATCH] Rework of Generics system for better output


diff --git a/src/org/jetbrains/java/decompiler/main/ClassWriter.java b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
index 815ec14..37d6c1c 100644
--- a/src/org/jetbrains/java/decompiler/main/ClassWriter.java
+++ b/src/org/jetbrains/java/decompiler/main/ClassWriter.java
@@ -334,9 +334,9 @@ public class ClassWriter {
 
     buffer.append(node.simpleName);
 
-    GenericClassDescriptor descriptor = getGenericClassDescriptor(cl);
-    if (descriptor != null && !descriptor.fparameters.isEmpty()) {
-      appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);
+    GenericClassDescriptor descriptor = cl.getSignature();
+    if (descriptor != null) {
+      descriptor.appendTypeParameters(buffer);
     }
 
     buffer.append(' ');
@@ -345,12 +345,7 @@ public class ClassWriter {
       VarType supertype = new VarType(cl.superClass.getString(), true);
       if (!VarType.VARTYPE_OBJECT.equals(supertype)) {
         buffer.append("extends ");
-        if (descriptor != null) {
-          buffer.append(GenericMain.getGenericCastTypeName(descriptor.superclass));
-        }
-        else {
-          buffer.append(ExprProcessor.getCastTypeName(supertype));
-        }
+        buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? supertype : descriptor.superclass));
         buffer.append(' ');
       }
     }
@@ -363,12 +358,7 @@ public class ClassWriter {
           if (i > 0) {
             buffer.append(", ");
           }
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(i)));
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(new VarType(cl.getInterface(i), true)));
-          }
+          buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? new VarType(cl.getInterface(i), true) : descriptor.superinterfaces.get(i)));
         }
         buffer.append(' ');
       }
@@ -406,21 +396,10 @@ public class ClassWriter {
 
     VarType fieldType = new VarType(fd.getDescriptor(), false);
 
-    GenericFieldDescriptor descriptor = null;
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)fd.getAttributes().getWithKey("Signature");
-      if (attr != null) {
-        descriptor = GenericMain.parseFieldSignature(attr.getSignature());
-      }
-    }
+    GenericFieldDescriptor descriptor = fd.getSignature();
 
     if (!isEnum) {
-      if (descriptor != null) {
-        buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));
-      }
-      else {
-        buffer.append(ExprProcessor.getCastTypeName(fieldType));
-      }
+      buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? fieldType : descriptor.type));
       buffer.append(' ');
     }
 
@@ -444,7 +423,7 @@ public class ClassWriter {
       else {
         buffer.append(" = ");
         // FIXME: special case field initializer. Can map to more than one method (constructor) and bytecode intruction.
-        buffer.append(initializer.toJava(indent, tracer));
+        ExprProcessor.getCastedExprent(initializer, descriptor == null ? fieldType : descriptor.type, buffer, indent, false, tracer);
       }
     }
     else if (fd.hasModifier(CodeConstants.ACC_FINAL) && fd.hasModifier(CodeConstants.ACC_STATIC)) {
@@ -592,6 +571,7 @@ public class ClassWriter {
       boolean clinit = false, init = false, dinit = false;
 
       MethodDescriptor md = MethodDescriptor.parseDescriptor(mt.getDescriptor());
+      DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR, md);
 
       int flags = mt.getAccessFlags();
       if ((flags & CodeConstants.ACC_NATIVE) != 0) {
@@ -646,25 +626,20 @@ public class ClassWriter {
         clinit = true;
       }
 
-      GenericMethodDescriptor descriptor = null;
-      if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-        StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)mt.getAttributes().getWithKey("Signature");
-        if (attr != null) {
-          descriptor = GenericMain.parseMethodSignature(attr.getSignature());
-          if (descriptor != null) {
-            long actualParams = md.params.length;
-            List<VarVersionPair> sigFields = methodWrapper.signatureFields;
-            if (sigFields != null) {
-              actualParams = sigFields.stream().filter(Objects::isNull).count();
-            }
-            else if (isEnum && init) actualParams -= 2;
-            if (actualParams != descriptor.params.size()) {
-              String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor() + " in " + cl.qualifiedName;
-              DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
-              descriptor = null;
-            }
-          }
+      GenericMethodDescriptor descriptor = mt.getSignature();
+      if (descriptor != null) {
+        long actualParams = md.params.length;
+        List<VarVersionPair> sigFields = methodWrapper.signatureFields;
+        if (sigFields != null) {
+          actualParams = sigFields.stream().filter(Objects::isNull).count();
+        }
+        else if (isEnum && init) actualParams -= 2;
+        if (actualParams != descriptor.params.size()) {
+          String message = "Inconsistent generic signature in method " + mt.getName() + " " + mt.getDescriptor() + " in " + cl.qualifiedName;
+          DecompilerContext.getLogger().writeMessage(message, IFernflowerLogger.Severity.WARN);
+          descriptor = null;
         }
+        md.addGenericDescriptor(descriptor);
       }
 
       boolean throwsExceptions = false;
@@ -673,18 +648,12 @@ public class ClassWriter {
       if (!clinit && !dinit) {
         boolean thisVar = !mt.hasModifier(CodeConstants.ACC_STATIC);
 
-        if (descriptor != null && !descriptor.fparameters.isEmpty()) {
-          appendTypeParameters(buffer, descriptor.fparameters, descriptor.fbounds);
-          buffer.append(' ');
+        if (descriptor != null) {
+          descriptor.appendTypeParameters(buffer);
         }
 
         if (!init) {
-          if (descriptor != null) {
-            buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
-          }
-          else {
-            buffer.append(ExprProcessor.getCastTypeName(md.ret));
-          }
+          buffer.append(ExprProcessor.getCastTypeName(descriptor == null ? md.ret : descriptor.ret));
           buffer.append(' ');
         }
 
@@ -705,6 +674,12 @@ public class ClassWriter {
         int index = isEnum && init ? 3 : thisVar ? 1 : 0;
         boolean hasDescriptor = descriptor != null;
         int start = isEnum && init && !hasDescriptor ? 2 : 0;
+
+        if (init && hasDescriptor && !isEnum &&
+            ((node.access & CodeConstants.ACC_STATIC) == 0) && node.type == ClassNode.CLASS_MEMBER) {
+          index++; //Enclosing class
+        }
+
         int params = hasDescriptor ? descriptor.params.size() : md.params.length;
         for (int i = start; i < params; i++) {
           if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {
@@ -718,45 +693,23 @@ public class ClassWriter {
               buffer.append("final ");
             }
 
-            if (descriptor != null) {
-              GenericType parameterType = descriptor.params.get(i);
-
-              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
-              if (isVarArg) {
-                parameterType = parameterType.decreaseArrayDim();
-              }
-
-              String typeName = GenericMain.getGenericCastTypeName(parameterType);
-              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
-                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
-                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
-              }
-
-              buffer.append(typeName);
+            VarType parameterType = descriptor == null ? md.params[i] : descriptor.params.get(i);
 
-              if (isVarArg) {
-                buffer.append("...");
-              }
+            boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
+            if (isVarArg) {
+              parameterType = parameterType.decreaseArrayDim();
             }
-            else {
-              VarType parameterType = md.params[i];
 
-              boolean isVarArg = (i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
-              if (isVarArg) {
-                parameterType = parameterType.decreaseArrayDim();
-              }
-
-              String typeName = ExprProcessor.getCastTypeName(parameterType);
-              if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
-                  DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
-                typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
-              }
+            String typeName = ExprProcessor.getCastTypeName(parameterType);
+            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) &&
+                DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
+              typeName = ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
+            }
 
-              buffer.append(typeName);
+            buffer.append(typeName);
 
-              if (isVarArg) {
-                buffer.append("...");
-              }
+            if (isVarArg) {
+              buffer.append("...");
             }
 
             buffer.append(' ');
@@ -767,7 +720,7 @@ public class ClassWriter {
             paramCount++;
           }
 
-          index += md.params[i].stackSize;
+          index += hasDescriptor ? descriptor.params.get(i).stackSize : md.params[i].stackSize;
         }
 
         buffer.append(')');
@@ -781,14 +734,11 @@ public class ClassWriter {
             if (i > 0) {
               buffer.append(", ");
             }
+            VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);
             if (descriptor != null && !descriptor.exceptions.isEmpty()) {
-              GenericType type = descriptor.exceptions.get(i);
-              buffer.append(GenericMain.getGenericCastTypeName(type));
-            }
-            else {
-              VarType type = new VarType(attr.getExcClassname(i, cl.getPool()), true);
-              buffer.append(ExprProcessor.getCastTypeName(type));
+              type = descriptor.exceptions.get(i);
             }
+            buffer.append(ExprProcessor.getCastTypeName(type));
           }
         }
       }
@@ -1039,38 +989,4 @@ public class ClassWriter {
       }
     }
   }
-
-  public static GenericClassDescriptor getGenericClassDescriptor(StructClass cl) {
-    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-      StructGenericSignatureAttribute attr = (StructGenericSignatureAttribute)cl.getAttributes().getWithKey("Signature");
-      if (attr != null) {
-        return GenericMain.parseClassSignature(attr.getSignature());
-      }
-    }
-    return null;
-  }
-
-  public static void appendTypeParameters(TextBuffer buffer, List<String> parameters, List<List<GenericType>> bounds) {
-    buffer.append('<');
-
-    for (int i = 0; i < parameters.size(); i++) {
-      if (i > 0) {
-        buffer.append(", ");
-      }
-
-      buffer.append(parameters.get(i));
-
-      List<GenericType> parameterBounds = bounds.get(i);
-      if (parameterBounds.size() > 1 || !"java/lang/Object".equals(parameterBounds.get(0).value)) {
-        buffer.append(" extends ");
-        buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(0)));
-        for (int j = 1; j < parameterBounds.size(); j++) {
-          buffer.append(" & ");
-          buffer.append(GenericMain.getGenericCastTypeName(parameterBounds.get(j)));
-        }
-      }
-    }
-
-    buffer.append('>');
-  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
index 39619ce..f0dff09 100644
--- a/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
+++ b/src/org/jetbrains/java/decompiler/main/DecompilerContext.java
@@ -33,6 +33,7 @@ public class DecompilerContext {
   public static final String CURRENT_CLASS_WRAPPER = "CURRENT_CLASS_WRAPPER";
   public static final String CURRENT_CLASS_NODE = "CURRENT_CLASS_NODE";
   public static final String CURRENT_METHOD_WRAPPER = "CURRENT_METHOD_WRAPPER";
+  public static final String CURRENT_METHOD_DESCRIPTOR = "CURRENT_METHOD_DESCRIPTOR";
   public static final String CURRENT_VAR_PROCESSOR = "CURRENT_VAR_PROCESSOR";
 
   private static final ThreadLocal<DecompilerContext> currentContext = new ThreadLocal<>();
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index e355ee9..aec95c1 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -19,6 +19,7 @@ import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
 import org.jetbrains.java.decompiler.main.extern.IBytecodeProvider;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
 import org.jetbrains.java.decompiler.main.extern.IResultSaver;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.renamer.IdentifierConverter;
@@ -27,7 +28,10 @@ import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.StructContext;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 
+import java.io.File;
+import java.util.HashSet;
 import java.util.Map;
+import java.util.Set;
 
 public class Fernflower implements IDecompiledData {
 
@@ -39,6 +43,10 @@ public class Fernflower implements IDecompiledData {
     DecompilerContext.initContext(options);
     DecompilerContext.setCounterContainer(new CounterContainer());
     DecompilerContext.setLogger(logger);
+
+    if (DecompilerContext.getOption(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH)) {
+      addAllClasspath();
+    }
   }
 
   public void decompileContext() {
@@ -92,4 +100,27 @@ public class Fernflower implements IDecompiledData {
       return null;
     }
   }
+
+  //TODO: Look into caching the metadata grabbed from the context info?
+  //Also test on J9 JRE to see if gathering of the classpath is the same.
+  private void addAllClasspath() {
+    Set<String> found = new HashSet<String>();
+    String[] props = { System.getProperty("java.class.path"), System.getProperty("sun.boot.class.path") };
+    for (String prop : props) {
+      if (prop == null)
+        continue;
+
+      for (final String path : prop.split(File.pathSeparator)) {
+        File file = new File(path);
+        if (found.contains(file.getAbsolutePath()))
+          continue;
+
+        if (file.exists() && (file.getName().endsWith(".class") || file.getName().endsWith(".jar"))) {
+          DecompilerContext.getLogger().writeMessage("Adding File to context from classpath: " + file, Severity.INFO);
+          structContext.addSpace(file, false);
+          found.add(file.getAbsolutePath());
+        }
+      }
+    }
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index c1ceecd..53a68e1 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -45,6 +45,8 @@ public interface IFernflowerPreferences {
   String LAMBDA_TO_ANONYMOUS_CLASS = "lac";
   String BYTECODE_SOURCE_MAPPING = "bsm";
 
+  String INCLUDE_ENTIRE_CLASSPATH = "iec";
+
   String LOG_LEVEL = "log";
   String MAX_PROCESSING_METHOD = "mpm";
   String RENAME_ENTITIES = "ren";
@@ -87,6 +89,8 @@ public interface IFernflowerPreferences {
     defaults.put(LAMBDA_TO_ANONYMOUS_CLASS, "0");
     defaults.put(BYTECODE_SOURCE_MAPPING, "0");
 
+    defaults.put(INCLUDE_ENTIRE_CLASSPATH, "0");
+
     defaults.put(LOG_LEVEL, IFernflowerLogger.Severity.INFO.name());
     defaults.put(MAX_PROCESSING_METHOD, "0");
     defaults.put(RENAME_ENTITIES, "0");
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
index 290c730..c707161 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/ExprProcessor.java
@@ -38,6 +38,8 @@ import org.jetbrains.java.decompiler.struct.consts.PooledConstant;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 
 import java.util.*;
 
@@ -696,7 +698,13 @@ public class ExprProcessor implements CodeConstants {
     else if (tp == CodeConstants.TYPE_VOID) {
       return "void";
     }
+    else if (tp == CodeConstants.TYPE_GENVAR && type.isGeneric()) {
+      return type.value;
+    }
     else if (tp == CodeConstants.TYPE_OBJECT) {
+      if (type.isGeneric()) {
+        return ((GenericType)type).getCastName();
+      }
       String ret = buildJavaClassName(type.value);
       if (getShort) {
         ret = DecompilerContext.getImportCollector().getShortName(ret);
@@ -813,6 +821,7 @@ public class ExprProcessor implements CodeConstants {
     lst = Exprent.sortIndexed(lst);
 
     for (Exprent expr : lst) {
+      expr.getInferredExprType(null);
       TextBuffer content = expr.toJava(indent, tracer);
       if (content.length() > 0) {
         if (expr.type != Exprent.EXPRENT_VAR || !((VarExprent)expr).isClassDef()) {
@@ -869,11 +878,11 @@ public class ExprProcessor implements CodeConstants {
                                          boolean castNull,
                                          boolean castAlways,
                                          BytecodeMappingTracer tracer) {
-    VarType rightType = exprent.getExprType();
+    VarType rightType = exprent.getInferredExprType(leftType);
 
     boolean cast =
       castAlways ||
-      (!leftType.isSuperset(rightType) && (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) ||
+      (Exprent.needsCast(leftType, rightType, false)) ||
       (castNull && rightType.type == CodeConstants.TYPE_NULL && !UNDEFINED_TYPE_STRING.equals(getTypeName(leftType))) ||
       (isIntConstant(exprent) && rightType.isStrictSuperset(leftType));
 
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
index 58017ef..32c7959 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/AssignmentExprent.java
@@ -105,8 +105,8 @@ public class AssignmentExprent extends Exprent {
 
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
-    VarType leftType = left.getExprType();
-    VarType rightType = right.getExprType();
+    VarType leftType = left.getInferredExprType(null);
+    VarType rightType = right.getInferredExprType(leftType);
 
     boolean fieldInClassInit = false, hiddenField = false;
     if (left.type == Exprent.EXPRENT_FIELD) { // first assignment to a final field. Field name without "this" in front of it
@@ -140,14 +140,8 @@ public class AssignmentExprent extends Exprent {
 
     TextBuffer res = right.toJava(indent, tracer);
 
-    if (condType == CONDITION_NONE &&
-        !leftType.isSuperset(rightType) &&
-        (rightType.equals(VarType.VARTYPE_OBJECT) || leftType.type != CodeConstants.TYPE_OBJECT)) {
-      if (right.getPrecedence() >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
-        res.enclose("(", ")");
-      }
-
-      res.prepend("(" + ExprProcessor.getCastTypeName(leftType) + ")");
+    if (condType == CONDITION_NONE) {
+      this.wrapInCast(leftType, rightType, res, right.getPrecedence());
     }
 
     buffer.append(condType == CONDITION_NONE ? " = " : OPERATORS[condType]).append(res);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
index 335c318..f6812fb 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ConstExprent.java
@@ -23,6 +23,7 @@ import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.struct.gen.FieldDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -388,7 +389,17 @@ public class ConstExprent extends Exprent {
   public void getBytecodeRange(BitSet values) {
     measureBytecode(values);
   }
-  
+
+  @Override
+  public VarType getInferredExprType(VarType upperBound)
+  {
+    if(constType == VarType.VARTYPE_CLASS) {
+      String stringVal = value.toString();
+      return GenericType.parse("Ljava/lang/Class<L" + stringVal + ";>;");
+    }
+    return super.getInferredExprType(upperBound);
+  }
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
@@ -417,4 +428,4 @@ public class ConstExprent extends Exprent {
 
     return true;
   }
-}
\ No newline at end of file
+}
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
index 0c3a1f9..722e306 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/ExitExprent.java
@@ -24,6 +24,7 @@ import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.struct.attr.StructExceptionsAttribute;
+import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
@@ -80,13 +81,18 @@ public class ExitExprent extends Exprent {
   @Override
   public TextBuffer toJava(int indent, BytecodeMappingTracer tracer) {
     tracer.addMapping(bytecode);
+    MethodDescriptor md = (MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR);
 
     if (exitType == EXIT_RETURN) {
       TextBuffer buffer = new TextBuffer("return");
 
       if (retType.type != CodeConstants.TYPE_VOID) {
+        VarType ret = retType;
+        if (md.genericInfo != null && md.genericInfo.ret != null) {
+          ret = md.genericInfo.ret;
+        }
         buffer.append(' ');
-        ExprProcessor.getCastedExprent(value, retType, buffer, indent, false, tracer);
+        ExprProcessor.getCastedExprent(value, ret, buffer, indent, false, false, tracer);
       }
 
       return buffer;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
index 63ff8b2..9bc2793 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/Exprent.java
@@ -15,13 +15,23 @@
  */
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
+import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.code.interpreter.Util;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.TextBuffer;
+import org.jetbrains.java.decompiler.main.ClassesProcessor.ClassNode;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.collectors.CounterContainer;
+import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.CheckTypesResult;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericBoundDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.IMatchable;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
@@ -67,6 +77,11 @@ public abstract class Exprent implements IMatchable {
     return VarType.VARTYPE_VOID;
   }
 
+  // TODO: This captures the state of upperBound, find a way to do it without modifying state?
+  public VarType getInferredExprType(VarType upperBound) {
+    return getExprType();
+  }
+
   public int getExprentUse() {
     return 0;
   }
@@ -184,7 +199,156 @@ public abstract class Exprent implements IMatchable {
       }
       return ret;
     }
-  
+
+  // FIXME: this should add constraint: upperBound :> ret and exit, with optionally adding more constraints from arguments (if this is a method call)
+  protected VarType gatherGenerics(VarType upperBound, VarType ret, List<String> fparams, List<VarType> genericArgs) {
+    Map<VarType, VarType> map = new HashMap<>();
+
+    // List<T> -> List<String>
+    if (upperBound != null && upperBound.isGeneric() && ret.isGeneric()) {
+      List<VarType> leftArgs = ((GenericType)upperBound).getArguments();
+      List<VarType> rightArgs = ((GenericType)ret).getArguments();
+      if (leftArgs.size() == rightArgs.size() && rightArgs.size() == fparams.size()) {
+        for (int i = 0; i < leftArgs.size(); i++) {
+          VarType left = leftArgs.get(i);
+          VarType right = rightArgs.get(i);
+          if (left != null && right.value.equals(fparams.get(i))) { //TODO: Out of order values, or different value names? ' <V,K> Map<K,V> newHashMap()' ?
+            genericArgs.add(left);
+            map.put(right, left);
+          } else {
+            genericArgs.clear();
+            map.clear();
+            break;
+          }
+        }
+      }
+    }
+
+    return map.isEmpty() ? ret : ret.remap(map);
+  }
+
+  protected void appendParameters(TextBuffer buf, List<VarType> genericArgs) {
+    if (genericArgs.isEmpty()) {
+      return;
+    }
+    buf.append("<");
+    //TODO: Check target output level and use <> operator?
+    for (int i = 0; i < genericArgs.size(); i++) {
+      buf.append(ExprProcessor.getCastTypeName(genericArgs.get(i)));
+      if(i + 1 < genericArgs.size()) {
+        buf.append(", ");
+      }
+    }
+    buf.append(">");
+  }
+
+  protected static Map<VarType, List<VarType>> getNamedGenerics() {
+    Map<VarType, List<VarType>> ret = new HashMap<>();
+    ClassNode class_ = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);
+    MethodWrapper method = (MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
+
+    Stack<GenericBoundDescriptor> stack = new Stack<>();
+
+    GenericMethodDescriptor mtd = method == null ? null : method.methodStruct.getSignature();
+    if (mtd != null) {
+      stack.push(mtd);
+    }
+
+    StructClass cls = class_.classStruct;
+    while (cls != null) {
+      if (cls.getSignature() != null) {
+        stack.push(cls.getSignature());
+      }
+      cls = cls.superClass == null ? null : DecompilerContext.getStructContext().getClass(cls.superClass.getString());
+    }
+    
+    while (!stack.isEmpty()) {
+      GenericBoundDescriptor gbd = stack.pop();
+      for (int x = 0; x < gbd.fparameters.size(); x++) {
+        ret.put(GenericType.parse("T" + gbd.fparameters.get(x) + ";"), gbd.fbounds.get(x));
+      }
+    }
+
+    return ret;
+  }
+
+  public static boolean needsCast(VarType left, VarType right, boolean allowObject) {
+    if (left.equals(right)) {
+      return false;
+    }
+    boolean needsCast = true; //!left.isSuperset(right) && (right.equals(VarType.VARTYPE_OBJECT) || left.type != CodeConstants.TYPE_OBJECT);
+
+    if (left.isGeneric()) {
+      Map<VarType, List<VarType>> names = getNamedGenerics();
+      int arrayDim = 0;
+
+      if (left.arrayDim == right.arrayDim) {
+        arrayDim = left.arrayDim;
+        left = left.resizeArrayDim(0);
+        right = right.resizeArrayDim(0);
+      }
+
+      List<VarType> types = names.get(right);
+      if (types == null) {
+        types = names.get(left);
+      }
+
+      if (types != null) {
+        boolean anyMatch = false; //TODO: allMatch instead of anyMatch?
+        for (VarType type : types) {
+          if (!allowObject && type.equals(VarType.VARTYPE_OBJECT) && right.equals(VarType.VARTYPE_OBJECT)) {
+            continue;
+          }
+          if (right.equals(VarType.VARTYPE_NULL)) { //Wildcards?
+            continue;
+          }
+          anyMatch |= Util.instanceOf(DecompilerContext.getStructContext(), right.value, type.value);
+        }
+
+        if (anyMatch) {
+          needsCast = false;
+        }
+      }
+      else {
+        if (right.equals(VarType.VARTYPE_NULL)) {
+          needsCast = false;
+        }
+        else {
+          needsCast = !Util.instanceOf(DecompilerContext.getStructContext(), right.value, left.value); //ToDo Check generic args?
+        }
+      }
+
+      if (arrayDim != 0) {
+        left = left.resizeArrayDim(arrayDim);
+      }
+    }
+    else {
+      if (right.equals(VarType.VARTYPE_NULL)) {
+        needsCast = false;
+      }
+      else if (left.type == CodeConstants.TYPE_OBJECT) {
+        needsCast = !Util.instanceOf(DecompilerContext.getStructContext(), right.value, left.value);
+      }
+      else {
+        needsCast = !left.isSuperset(right);
+      }
+    }
+
+    return needsCast;
+  }
+  protected void wrapInCast(VarType left, VarType right, TextBuffer buf, int precedence) {
+    boolean needsCast = needsCast(left, right, false);
+    if (!needsCast) {
+      return;
+    }
+
+    if (precedence >= FunctionExprent.getPrecedence(FunctionExprent.FUNCTION_CAST)) {
+      buf.enclose("(", ")");
+    }
+
+    buf.prepend("(" + ExprProcessor.getCastTypeName(left) + ")");
+  }
+
   // *****************************************************************************
   // IMatchable implementation
   // *****************************************************************************
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
index 959fdf6..bdf1d94 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FieldExprent.java
@@ -23,10 +23,13 @@ import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.main.rels.MethodWrapper;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
 import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
+import org.jetbrains.java.decompiler.struct.StructClass;
+import org.jetbrains.java.decompiler.struct.StructField;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.LinkConstant;
 import org.jetbrains.java.decompiler.struct.gen.FieldDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -35,7 +38,9 @@ import org.jetbrains.java.decompiler.util.TextUtil;
 
 import java.util.ArrayList;
 import java.util.BitSet;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class FieldExprent extends Exprent {
   private final String name;
@@ -65,6 +70,52 @@ public class FieldExprent extends Exprent {
   }
 
   @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    VarType instType = instance == null ? null : instance.getInferredExprType(upperBound);
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    VarType ret = getFieldDeclaration(cl, instType);
+    return ret == null ? getExprType() : ret;
+  }
+
+  private VarType getFieldDeclaration(StructClass cl, VarType instType) {
+    if (cl == null) {
+      return null;
+    }
+
+    StructField ft = cl.getField(name, descriptor.descriptorString);
+    if (ft != null) {
+      if (ft.getSignature() != null) {
+        if (instType != null && instType.isGeneric() && cl.getSignature() != null) {
+          Map<VarType, VarType> map = new HashMap<>();
+          List<VarType> args = ((GenericType)instType).getArguments();
+          for (int x = 0; x < args.size(); x++) {
+            map.put(GenericType.parse("T" + cl.getSignature().fparameters.get(x) + ";"), args.get(x));
+          }
+          return ft.getSignature().type.remap(map);
+        }
+        return ft.getSignature().type;
+      }
+      else {
+        return getExprType(); //Edit out with non-generic type
+      }
+    }
+
+    for (String inf : cl.getInterfaceNames()) {
+      VarType ret = getFieldDeclaration(DecompilerContext.getStructContext().getClass(inf), instType == null ? null : instType.castDown(inf));
+      if (ret != null) {
+        return ret;
+      }
+    }
+
+    if (cl.superClass == null) {
+      return null;
+    }
+
+    String _super = cl.superClass.getString();
+    return getFieldDeclaration(DecompilerContext.getStructContext().getClass(_super), instType == null ? null : instType.castDown(_super));
+  }
+
+  @Override
   public int getExprentUse() {
     return instance == null ? Exprent.MULTIPLE_USES : instance.getExprentUse() & Exprent.MULTIPLE_USES;
   }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
index cbc78b5..0fd47dc 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/FunctionExprent.java
@@ -16,6 +16,8 @@
 package org.jetbrains.java.decompiler.modules.decompiler.exps;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.code.interpreter.Util;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.TextBuffer;
 import org.jetbrains.java.decompiler.main.collectors.BytecodeMappingTracer;
 import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
@@ -197,6 +199,7 @@ public class FunctionExprent extends Exprent {
   private int funcType;
   private VarType implicitType;
   private final List<Exprent> lstOperands;
+  private boolean needsCast = true;
 
   public FunctionExprent(int funcType, ListStack<Exprent> stack, BitSet bytecodeOffsets) {
     this(funcType, new ArrayList<>(), bytecodeOffsets);
@@ -308,6 +311,24 @@ public class FunctionExprent extends Exprent {
   }
 
   @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    if (funcType == FUNCTION_CAST) {
+      this.needsCast = true;
+      VarType right = lstOperands.get(0).getInferredExprType(upperBound);
+      VarType cast = lstOperands.get(1).getExprType();
+      this.needsCast = this.needsCast(cast, right, true);
+      //TODO: Capture generics to make cast better?
+      /*if (upperBound != null && needsCast && upperBound.type == CodeConstants.TYPE_OBJECT) {
+        ((ConstExprent)lstOperands.get(1)).setConstType(upperBound);
+        return upperBound;
+      }*/
+      return needsCast ? cast : right;
+    }
+    return getExprType();
+  }
+
+
+  @Override
   public int getExprentUse() {
     if (funcType >= FUNCTION_IMM && funcType <= FUNCTION_PPI) {
       return 0;
@@ -473,6 +494,9 @@ public class FunctionExprent extends Exprent {
       case FUNCTION_NEG:
         return wrapOperandString(lstOperands.get(0), true, indent, tracer).prepend("-");
       case FUNCTION_CAST:
+        if (!needsCast) {
+          return lstOperands.get(0).toJava(indent, tracer);
+        }
         return lstOperands.get(1).toJava(indent, tracer).enclose("(", ")").append(wrapOperandString(lstOperands.get(0), true, indent, tracer));
       case FUNCTION_ARRAY_LENGTH:
         Exprent arr = lstOperands.get(0);
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
index a38c2ee..c29f06f 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/InvocationExprent.java
@@ -32,6 +32,8 @@ import org.jetbrains.java.decompiler.struct.consts.LinkConstant;
 import org.jetbrains.java.decompiler.struct.consts.PooledConstant;
 import org.jetbrains.java.decompiler.struct.gen.MethodDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -67,6 +69,7 @@ public class InvocationExprent extends Exprent {
   private int invocationTyp = INVOKE_VIRTUAL;
   private List<Exprent> lstParameters = new ArrayList<>();
   private List<PooledConstant> bootstrapArguments;
+  private List<VarType> genericArgs = new ArrayList<>();
 
   public InvocationExprent() {
     super(EXPRENT_INVOCATION);
@@ -174,6 +177,62 @@ public class InvocationExprent extends Exprent {
     return descriptor.ret;
   }
 
+
+  @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    VarType instType = instance == null ? null : instance.getInferredExprType(upperBound);
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    VarType ret = getMethodDeclaration(cl, instType, upperBound);
+    return ret == null ? getExprType() : ret;
+  }
+
+  private VarType getMethodDeclaration(StructClass cl, VarType instType, VarType upperBound)
+  {
+    if (cl == null) {
+      return null;
+    }
+
+    StructMethod mt = cl.getMethod(name, stringDescriptor);
+    if (mt != null) {
+      GenericMethodDescriptor desc = mt.getSignature();
+      
+      if (desc == null) {
+        return MethodDescriptor.parseDescriptor(mt.getDescriptor()).ret;
+      }
+
+      VarType ret = desc.ret;
+
+      if (instType != null && instType.isGeneric() && cl.getSignature() != null) {
+        Map<VarType, VarType> map = new HashMap<>();
+        List<VarType> args = ((GenericType)instType).getArguments();
+        for (int x = 0; x < args.size(); x++) {
+          map.put(GenericType.parse("T" + cl.getSignature().fparameters.get(x) + ";"), args.get(x));
+        }
+
+        if (!map.isEmpty()) {
+          ret = ret.remap(map);
+        }
+      }
+
+      return this.gatherGenerics(upperBound, ret, desc.fparameters, genericArgs);
+    }
+
+    for (String inf : cl.getInterfaceNames()) {
+      VarType ret = getMethodDeclaration(DecompilerContext.getStructContext().getClass(inf), instType == null ? null : instType.castDown(inf), upperBound);
+      if (ret != null) {
+        return ret;
+      }
+    }
+
+    if (cl.superClass == null) {
+      return null;
+    }
+
+    String _super = cl.superClass.getString();
+    return getMethodDeclaration(DecompilerContext.getStructContext().getClass(_super), instType == null ? null : instType.castDown(_super), upperBound);
+  }
+
+
   @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
@@ -215,6 +274,108 @@ public class InvocationExprent extends Exprent {
 
     tracer.addMapping(bytecode);
 
+    List<StructMethod> matches = getMatchedDescriptors();
+    BitSet setAmbiguousParameters = getAmbiguousParameters(matches);
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    StructMethod desc = cl.getMethod(name, stringDescriptor);
+
+    Map<VarType, VarType> genArgs = new HashMap<>();
+
+    // building generic info from the instance
+    // TODO: merge with castDown?
+    VarType inferred = instance == null ? null : instance.getInferredExprType(null);
+    if (cl != null && cl.getSignature() != null && instance != null && inferred.isGeneric()) {
+      GenericType genType = (GenericType)inferred;
+      if (genType.getArguments().size() == cl.getSignature().fparameters.size()) {
+        for (int i = 0; i < cl.getSignature().fparameters.size(); i++) {
+          VarType from = GenericType.parse("T" + cl.getSignature().fparameters.get(i) + ";");
+          VarType to = genType.getArguments().get(i);
+          if (from != null && to != null) {
+            genArgs.put(from, to);
+          }
+        }
+      }
+    }
+
+    List<VarVersionPair> sigFields = null;
+    boolean isEnum = false;
+    if (functype == TYP_INIT) {
+      ClassNode newNode = DecompilerContext.getClassProcessor().getMapRootClasses().get(classname);
+
+      if (newNode != null) {  // own class
+        if (newNode.getWrapper() != null) {
+          sigFields = newNode.getWrapper().getMethodWrapper(CodeConstants.INIT_NAME, stringDescriptor).signatureFields;
+        }
+        else {
+          if (newNode.type == ClassNode.CLASS_MEMBER && (newNode.access & CodeConstants.ACC_STATIC) == 0) { // non-static member class
+            sigFields = new ArrayList<>(Collections.nCopies(lstParameters.size(), (VarVersionPair)null));
+            sigFields.set(0, new VarVersionPair(-1, 0));
+          }
+        }
+        isEnum = newNode.classStruct.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
+      }
+    }
+
+    // use type args inferred from the left during getInferredExprType call
+    List<VarType> genericArgs = new ArrayList<>(this.genericArgs);
+
+    // check if there's any type arguments we need to infer
+    // FIXME: this should add and solve constraints from args, and fill fparameters/genericArgs that way
+    if (desc != null) {
+      GenericMethodDescriptor signature = desc.getSignature();
+      if (signature != null && signature.params.size() == lstParameters.size() && signature.fparameters.size() != 0) {
+        // only infer them if they weren't inferred from the outside
+        // FIXME: more cases
+        if (genericArgs.size() == 0) {
+          int start = isEnum ? 2 : 0;
+          for (int i = start; i < lstParameters.size(); i++) {
+
+            VarType type = desc.getSignature().params.get(i);
+
+            // applying generic info from the signature
+            VarType remappedType = type.remap(genArgs);
+            if (type != remappedType) {
+              type = remappedType;
+            }
+            // heuristics
+            for (int p = 0; p < signature.fparameters.size(); p++) {
+              VarType toMatch = GenericType.parse("T" + signature.fparameters.get(p) + ";");
+              if (!genArgs.containsKey(toMatch)) {
+                // <..., T, ...> doStuff(..., T arg, ...) => match T with the exact type of arg (String)
+                VarType argType = lstParameters.get(i).getInferredExprType(type);
+                if (toMatch.equals(type)) {
+                  genArgs.put(toMatch, argType);
+                }
+                // <..., T, ...> doStuff(..., Cls<T> arg, ...) => match arg with Cls<String>
+                if (type.isGeneric() && argType.isGeneric()) {
+                  GenericType gType = (GenericType) type;
+                  GenericType gArgType = (GenericType) argType;
+                  if (gType.getArguments().size() == gArgType.getArguments().size()) {
+                    for (int ip = 0; ip < gType.getArguments().size(); ip++) {
+                      if (gType.getArguments().get(ip).equals(toMatch)) {
+                        // T is in Cls<T>, arg is Cls<String> -> put (T -> String) in the map
+                        genArgs.put(toMatch, gArgType.getArguments().get(ip));
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+          for (int p = 0; p < signature.fparameters.size(); p++) {
+            VarType type = GenericType.parse("T" + signature.fparameters.get(p) + ";");
+            VarType newType = type.remap(genArgs);
+            if(type == newType) {
+              // some args are not remapped, don't use any, rely on javac to infer them
+              genericArgs.clear();
+              break;
+            }
+            genericArgs.add(newType);
+          }
+        }
+      }
+    }
+
     if (isStatic) {
       ClassNode node = (ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);
       if (node == null || !classname.equals(node.classStruct.qualifiedName)) {
@@ -258,7 +419,7 @@ public class InvocationExprent extends Exprent {
         else if (instance != null) {
           TextBuffer res = instance.toJava(indent, tracer);
 
-          VarType rightType = instance.getExprType();
+          VarType rightType = instance.getInferredExprType(null);
           VarType leftType = new VarType(CodeConstants.TYPE_OBJECT, 0, classname);
 
           if (rightType.equals(VarType.VARTYPE_OBJECT) && !leftType.equals(rightType)) {
@@ -287,6 +448,7 @@ public class InvocationExprent extends Exprent {
 
         if (buf.length() > 0) {
           buf.append(".");
+          this.appendParameters(buf, genericArgs);
         }
 
         buf.append(name);
@@ -315,26 +477,7 @@ public class InvocationExprent extends Exprent {
         }
     }
 
-    List<VarVersionPair> sigFields = null;
-    boolean isEnum = false;
-    if (functype == TYP_INIT) {
-      ClassNode newNode = DecompilerContext.getClassProcessor().getMapRootClasses().get(classname);
 
-      if (newNode != null) {  // own class
-        if (newNode.getWrapper() != null) {
-          sigFields = newNode.getWrapper().getMethodWrapper(CodeConstants.INIT_NAME, stringDescriptor).signatureFields;
-        }
-        else {
-          if (newNode.type == ClassNode.CLASS_MEMBER && (newNode.access & CodeConstants.ACC_STATIC) == 0) { // non-static member class
-            sigFields = new ArrayList<>(Collections.nCopies(lstParameters.size(), (VarVersionPair)null));
-            sigFields.set(0, new VarVersionPair(-1, 0));
-          }
-        }
-        isEnum = newNode.classStruct.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
-      }
-    }
-
-    BitSet setAmbiguousParameters = getAmbiguousParameters();
 
     boolean firstParameter = true;
     int start = isEnum ? 2 : 0;
@@ -346,7 +489,27 @@ public class InvocationExprent extends Exprent {
 
         TextBuffer buff = new TextBuffer();
         boolean ambiguous = setAmbiguousParameters.get(i);
-        ExprProcessor.getCastedExprent(lstParameters.get(i), descriptor.params[i], buff, indent, true, ambiguous, tracer);
+        VarType type = descriptor.params[i];
+
+        // using info from the generic signature
+        if (desc != null && desc.getSignature() != null && desc.getSignature().params.size() == lstParameters.size()) {
+          type = desc.getSignature().params.get(i);
+        }
+
+        // applying generic info from the signature
+        VarType remappedType = type.remap(genArgs);
+        if(type != remappedType) {
+          type = remappedType;
+        }
+
+        // this hack is now replaced by the argument inference up top
+        /*// not passing it along if what we get back is more specific
+        VarType exprType = lstParameters.get(i).getInferredExprType(type);
+        if (exprType != null && type != null && type.type == CodeConstants.TYPE_GENVAR) {
+          type = exprType;
+        }*/
+
+        ExprProcessor.getCastedExprent(lstParameters.get(i), type, buff, indent, true, ambiguous, tracer);
         buf.append(buff);
 
         firstParameter = false;
@@ -358,12 +521,11 @@ public class InvocationExprent extends Exprent {
     return buf;
   }
 
-  private BitSet getAmbiguousParameters() {
+  private List<StructMethod> getMatchedDescriptors() {
+    List<StructMethod> matches = new ArrayList<StructMethod>();
     StructClass cl = DecompilerContext.getStructContext().getClass(classname);
-    if (cl == null) return EMPTY_BIT_SET;
+    if (cl == null) return matches;
 
-    // check number of matches
-    List<MethodDescriptor> matches = new ArrayList<>();
     nextMethod:
     for (StructMethod mt : cl.getMethods()) {
       if (name.equals(mt.getName())) {
@@ -374,11 +536,19 @@ public class InvocationExprent extends Exprent {
               continue nextMethod;
             }
           }
-          matches.add(md);
+          matches.add(mt);
         }
       }
     }
-    if (matches.size() == 1) return EMPTY_BIT_SET;
+
+    return matches;
+  }
+
+  private BitSet getAmbiguousParameters(List<StructMethod> matches) {
+    StructClass cl = DecompilerContext.getStructContext().getClass(classname);
+    if (cl == null || matches.size() == 1) {
+      return EMPTY_BIT_SET;
+    }
 
     // check if a call is unambiguous
     StructMethod mt = cl.getMethod(InterpreterUtil.makeUniqueKey(name, stringDescriptor));
@@ -392,7 +562,9 @@ public class InvocationExprent extends Exprent {
             break;
           }
         }
-        if (exact) return EMPTY_BIT_SET;
+        if (exact) {
+          return EMPTY_BIT_SET;
+        }
       }
     }
 
@@ -400,7 +572,13 @@ public class InvocationExprent extends Exprent {
     BitSet ambiguous = new BitSet(descriptor.params.length);
     for (int i = 0; i < descriptor.params.length; i++) {
       VarType paramType = descriptor.params[i];
-      for (MethodDescriptor md : matches) {
+      for (StructMethod mtt : matches) {
+
+        if (mtt.getSignature() != null && mtt.getSignature().params.get(i).isGeneric()) {
+          break;
+        }
+
+        MethodDescriptor md = MethodDescriptor.parseDescriptor(mtt.getDescriptor());
         if (!paramType.equals(md.params[i])) {
           ambiguous.set(i);
           break;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
index da3f3aa..324e016 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/NewExprent.java
@@ -29,7 +29,6 @@ import org.jetbrains.java.decompiler.modules.decompiler.vars.VarVersionPair;
 import org.jetbrains.java.decompiler.struct.StructClass;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
-import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 import org.jetbrains.java.decompiler.util.ListStack;
 
@@ -47,6 +46,7 @@ public class NewExprent extends Exprent {
   private boolean anonymous;
   private boolean lambda;
   private boolean enumConst;
+  private List<VarType> genericArgs = new ArrayList<>();
 
   public NewExprent(VarType newType, ListStack<Exprent> stack, int arrayDim, BitSet bytecodeOffsets) {
     this(newType, getDimensions(arrayDim, stack), bytecodeOffsets);
@@ -86,6 +86,24 @@ public class NewExprent extends Exprent {
   }
 
   @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    genericArgs.clear();
+    if (newType.type == CodeConstants.TYPE_OBJECT && newType.arrayDim == 0) {
+      StructClass node = DecompilerContext.getStructContext().getClass(newType.value);
+
+      if (node != null && node.getSignature() != null) {
+        GenericClassDescriptor sig = node.getSignature();
+        VarType _new = this.gatherGenerics(upperBound, sig.genericType, sig.fparameters, genericArgs);
+        if (sig.genericType != _new) {
+          return _new;
+        }
+      }
+    }
+    
+    return getExprType();
+  }
+
+  @Override
   public CheckTypesResult checkExprTypeBounds() {
     CheckTypesResult result = new CheckTypesResult();
 
@@ -185,17 +203,17 @@ public class NewExprent extends Exprent {
           }
         }
 
-        GenericClassDescriptor descriptor = ClassWriter.getGenericClassDescriptor(child.classStruct);
+        GenericClassDescriptor descriptor = child.getWrapper().getClassStruct().getSignature();
         if (descriptor != null) {
           if (descriptor.superinterfaces.isEmpty()) {
-            buf.append(GenericMain.getGenericCastTypeName(descriptor.superclass));
+            buf.append(ExprProcessor.getCastTypeName(descriptor.superclass));
           }
           else {
             if (descriptor.superinterfaces.size() > 1 && !lambda) {
               DecompilerContext.getLogger().writeMessage("Inconsistent anonymous class signature: " + child.classStruct.qualifiedName,
                                                          IFernflowerLogger.Severity.WARN);
             }
-            buf.append(GenericMain.getGenericCastTypeName(descriptor.superinterfaces.get(0)));
+            buf.append(ExprProcessor.getCastTypeName(descriptor.superinterfaces.get(0)));
           }
         }
         else {
@@ -203,6 +221,7 @@ public class NewExprent extends Exprent {
         }
       }
 
+      appendParameters(buf, genericArgs);
       buf.append('(');
 
       if (!lambda && constructor != null) {
@@ -320,6 +339,7 @@ public class NewExprent extends Exprent {
 
         int start = enumConst ? 2 : 0;
         if (!enumConst || start < lstParameters.size()) {
+          appendParameters(buf, genericArgs);
           buf.append('(');
 
           boolean firstParam = true;
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
index f5d8cbe..747f4ae 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/exps/VarExprent.java
@@ -37,6 +37,7 @@ import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTypeTableAtt
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
 import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.struct.match.MatchEngine;
 import org.jetbrains.java.decompiler.struct.match.MatchNode;
 import org.jetbrains.java.decompiler.struct.match.MatchNode.RuleValue;
@@ -80,6 +81,22 @@ public class VarExprent extends Exprent {
   }
 
   @Override
+  public VarType getInferredExprType(VarType upperBound) {
+    if (lvt != null && lvt.getSignature() != null) {
+      // TODO; figure out why it's crashing, ugly fix for now
+      try {
+        return GenericType.parse(lvt.getSignature());
+      } catch (StringIndexOutOfBoundsException ex) {
+        ex.printStackTrace();
+      }
+    }
+    else if (lvt != null) {
+      return lvt.getVarType();
+    }
+    return getVarType();
+  }
+
+  @Override
   public int getExprentUse() {
     return Exprent.MULTIPLE_USES | Exprent.SIDE_EFFECTS_FREE;
   }
@@ -156,7 +173,7 @@ public class VarExprent extends Exprent {
           if (lvt.getSignature() != null) {
             GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(lvt.getSignature());
             if (descriptor != null) {
-              buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));
+              buffer.append(ExprProcessor.getCastTypeName(descriptor.type));
               return;
             }
           }
@@ -174,17 +191,13 @@ public class VarExprent extends Exprent {
         int visibleOffset = bytecode == null ? -1 : bytecode.length();
         if (originalIndex != null) {
           // first try from signature
-          if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
-            StructLocalVariableTypeTableAttribute attr = (StructLocalVariableTypeTableAttribute)method.methodStruct.getAttributes()
-              .getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE);
-            if (attr != null) {
-              String signature = attr.getSignature(originalIndex, visibleOffset);
-              if (signature != null) {
-                GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(signature);
-                if (descriptor != null) {
-                  buffer.append(GenericMain.getGenericCastTypeName(descriptor.type));
-                  return;
-                }
+          if (method.methodStruct.getLocalVariableTypeAttr() != null) {
+            String signature = method.methodStruct.getLocalVariableTypeAttr().getSignature(originalIndex, visibleOffset);
+            if (signature != null) {
+              GenericFieldDescriptor descriptor = GenericMain.parseFieldSignature(signature);
+              if (descriptor != null) {
+                buffer.append(ExprProcessor.getCastTypeName(descriptor.type));
+                return;
               }
             }
           }
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
index bb55e0f..55bbc2c 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/stats/DoStatement.java
@@ -139,6 +139,7 @@ public class DoStatement extends Statement {
         break;
       case LOOP_FOREACH:
         buf.appendIndent(indent).append("for(").append(initExprent.get(0).toJava(indent, tracer));
+        incExprent.get(0).getInferredExprType(null); //TODO: Find a better then null? For now just calls it to clear casts if needed
         buf.append(" : ").append(incExprent.get(0).toJava(indent, tracer)).append(") {").appendLineSeparator();
         tracer.incrementCurrentSourceLine();
         buf.append(ExprProcessor.jmpWrapper(first, indent + 1, true, tracer));
diff --git a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
index 16cbc34..e46116f 100644
--- a/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
+++ b/src/org/jetbrains/java/decompiler/modules/decompiler/vars/VarDefinitionHelper.java
@@ -908,7 +908,7 @@ public class VarDefinitionHelper {
     String cast;
     private VarInfo(LocalVariable lvt, VarType type) {
       if (lvt != null && lvt.getSignature() != null) {
-        cast = GenericMain.getGenericCastTypeName(new GenericType(lvt.getSignature()));
+        cast = ExprProcessor.getCastTypeName(GenericType.parse(lvt.getSignature()));
       }
       else if (lvt != null) {
         cast = ExprProcessor.getCastTypeName(lvt.getVarType(), false);
diff --git a/src/org/jetbrains/java/decompiler/struct/StructClass.java b/src/org/jetbrains/java/decompiler/struct/StructClass.java
index 1c1a930..c68d329 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructClass.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructClass.java
@@ -16,8 +16,14 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
 import org.jetbrains.java.decompiler.struct.consts.PrimitiveConstant;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericClassDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.struct.lazy.LazyLoader;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
@@ -61,6 +67,7 @@ public class StructClass extends StructMember {
   private final VBStyleCollection<StructField, String> fields;
   private final VBStyleCollection<StructMethod, String> methods;
   private final Map<String, Map<Integer, String>> enumSwitchMap = new HashMap<>();
+  private GenericClassDescriptor signature = null;
 
   private ConstantPool pool;
 
@@ -206,4 +213,18 @@ public class StructClass extends StructMember {
   public String toString() {
     return qualifiedName;
   }
+
+  public GenericClassDescriptor getSignature() {
+    return signature;
+  }
+
+  @Override
+  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseClassSignature(qualifiedName, signature.getSignature());
+    }
+    return attribute;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructField.java b/src/org/jetbrains/java/decompiler/struct/StructField.java
index 87ba1d8..438746b 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructField.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructField.java
@@ -15,7 +15,13 @@
  */
 package org.jetbrains.java.decompiler.struct;
 
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
+import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericFieldDescriptor;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 
 import java.io.IOException;
@@ -33,7 +39,7 @@ public class StructField extends StructMember {
 
   private final String name;
   private final String descriptor;
-
+  private GenericFieldDescriptor signature;
 
   public StructField(DataInputFullStream in, StructClass clStruct) throws IOException {
     accessFlags = in.readUnsignedShort();
@@ -60,4 +66,18 @@ public class StructField extends StructMember {
   public String toString() {
     return name;
   }
+
+  public GenericFieldDescriptor getSignature() {
+    return signature;
+  }
+
+  @Override
+  protected StructGeneralAttribute readAttribute(DataInputFullStream in, ConstantPool pool, String name) throws IOException {
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseFieldSignature(signature.getSignature());
+    }
+    return attribute;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/StructMethod.java b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
index d398c5e..f962a31 100644
--- a/src/org/jetbrains/java/decompiler/struct/StructMethod.java
+++ b/src/org/jetbrains/java/decompiler/struct/StructMethod.java
@@ -16,9 +16,15 @@
 package org.jetbrains.java.decompiler.struct;
 
 import org.jetbrains.java.decompiler.code.*;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences;
 import org.jetbrains.java.decompiler.struct.attr.StructGeneralAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructGenericSignatureAttribute;
 import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTableAttribute;
+import org.jetbrains.java.decompiler.struct.attr.StructLocalVariableTypeTableAttribute;
 import org.jetbrains.java.decompiler.struct.consts.ConstantPool;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMain;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 import org.jetbrains.java.decompiler.util.DataInputFullStream;
 import org.jetbrains.java.decompiler.util.VBStyleCollection;
 
@@ -46,6 +52,7 @@ public class StructMethod extends StructMember {
   private final StructClass classStruct;
   private final String name;
   private final String descriptor;
+  private GenericMethodDescriptor signature;
 
   private boolean containsCode = false;
   private int localVariables = 0;
@@ -99,7 +106,13 @@ public class StructMethod extends StructMember {
       return null;
     }
 
-    return super.readAttribute(in, pool, name);
+    StructGeneralAttribute attribute = super.readAttribute(in, pool, name);
+    if ("Signature".equals(name) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
+      StructGenericSignatureAttribute signature = (StructGenericSignatureAttribute)attribute;
+      this.signature = GenericMain.parseMethodSignature(signature.getSignature());
+    }
+
+    return attribute;
   }
 
   public void expandData() throws IOException {
@@ -394,8 +407,16 @@ public class StructMethod extends StructMember {
     return (StructLocalVariableTableAttribute)getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TABLE);
   }
 
+  public StructLocalVariableTypeTableAttribute getLocalVariableTypeAttr() {
+    return (StructLocalVariableTypeTableAttribute)getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_LOCAL_VARIABLE_TYPE_TABLE);
+  }
+
   @Override
   public String toString() {
     return name;
   }
+
+  public GenericMethodDescriptor getSignature() {
+    return signature;
+  }
 }
\ No newline at end of file
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
index a2fd20c..aa55b6d 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/FieldDescriptor.java
@@ -60,4 +60,9 @@ public class FieldDescriptor {
   public int hashCode() {
     return type.hashCode();
   }
+
+  @Override
+  public String toString() {
+    return descriptorString;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
index 3b5abb4..7d55d7e 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/MethodDescriptor.java
@@ -16,6 +16,7 @@
 package org.jetbrains.java.decompiler.struct.gen;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericMethodDescriptor;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -25,6 +26,7 @@ public class MethodDescriptor {
 
   public final VarType[] params;
   public final VarType ret;
+  public GenericMethodDescriptor genericInfo;
 
   private MethodDescriptor(VarType[] params, VarType ret) {
     this.params = params;
@@ -78,6 +80,10 @@ public class MethodDescriptor {
     return new MethodDescriptor(params, ret);
   }
 
+  public void addGenericDescriptor(GenericMethodDescriptor desc) {
+    this.genericInfo = desc;
+  }
+
   public String buildNewDescriptor(NewClassNameBuilder builder) {
     boolean updated = false;
 
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
index 1eb177f..97574a8 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/VarType.java
@@ -15,7 +15,14 @@
  */
 package org.jetbrains.java.decompiler.struct.gen;
 
+import java.util.Map;
+
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
+import org.jetbrains.java.decompiler.struct.StructClass;
+import org.jetbrains.java.decompiler.struct.StructContext;
+import org.jetbrains.java.decompiler.struct.gen.generics.GenericType;
 import org.jetbrains.java.decompiler.util.InterpreterUtil;
 
 public class VarType {  // TODO: optimize switch
@@ -59,7 +66,7 @@ public class VarType {  // TODO: optimize switch
     this(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
   }
 
-  private VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
+  protected VarType(int type, int arrayDim, String value, int typeFamily, int stackSize, boolean falseBoolean) {
     this.type = type;
     this.arrayDim = arrayDim;
     this.value = value;
@@ -151,7 +158,7 @@ public class VarType {  // TODO: optimize switch
     }
   }
 
-  private static int getStackSize(int type, int arrayDim) {
+  protected static int getStackSize(int type, int arrayDim) {
     if (arrayDim > 0) {
       return 1;
     }
@@ -168,7 +175,7 @@ public class VarType {  // TODO: optimize switch
     }
   }
 
-  private static int getFamily(int type, int arrayDim) {
+  protected static int getFamily(int type, int arrayDim) {
     if (arrayDim > 0) {
       return CodeConstants.TYPE_FAMILY_OBJECT;
     }
@@ -270,6 +277,15 @@ public class VarType {  // TODO: optimize switch
   }
 
   @Override
+  public int hashCode() {
+    int result = 1;
+    result = 37 * result + type;
+    result = 37 * result + arrayDim;
+    result = 37 * result + (value == null ? 0 : value.hashCode());
+    return result;
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (o == this) {
       return true;
@@ -415,4 +431,65 @@ public class VarType {  // TODO: optimize switch
         throw new IllegalArgumentException("Invalid type: " + c);
     }
   }
+
+  public boolean isGeneric() {
+    return false;
+  }
+
+  public VarType remap(Map<VarType, VarType> map) {
+    if (map.containsKey(this)) {
+      return map.get(this);
+    }
+    return this;
+  }
+
+  // WARNING: RECURSIVE May cause depth issues, but we'll have to see
+  public VarType castDown(String targetAncestor) {
+    if ("java/lang/Object".equals(targetAncestor)) {
+      return VARTYPE_OBJECT;
+    }
+
+    if (this.value.equals(targetAncestor)) {
+      return this;
+    }
+
+    StructContext stCtx = DecompilerContext.getStructContext();
+    StructClass _this = stCtx.getClass(this.value);
+
+    if (_this == null) {
+      DecompilerContext.getLogger().writeMessage("Missing class information for downcast: " + this.value , Severity.WARN);
+      return null;
+    }
+
+    if (_this.getSignature() != null) {
+      for (VarType inf : _this.getSignature().superinterfaces) {
+        VarType ret = inf.castDown(targetAncestor);
+        if (ret != null) {
+          return ret;
+        }
+      }
+
+      VarType ret = _this.getSignature().superclass.castDown(targetAncestor);
+      if (ret != null) {
+        return ret;
+      }
+    }
+    else {
+      for (String inf : _this.getInterfaceNames()) {
+        VarType ret = new VarType("L" + inf + ":").castDown(targetAncestor);
+        if (ret != null) {
+          return ret;
+        }
+      }
+
+      String superClass = _this.superClass == null ? null : _this.superClass.getString();
+      if (superClass == null || "java/lang/Object".equals(superClass)) {
+        return null;
+      }
+
+      return new VarType("L" + superClass + ";").castDown(targetAncestor);
+    }
+
+    return null;
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericBoundDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericBoundDescriptor.java
new file mode 100644
index 0000000..4d58bf3
--- /dev/null
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericBoundDescriptor.java
@@ -0,0 +1,66 @@
+package org.jetbrains.java.decompiler.struct.gen.generics;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.jetbrains.java.decompiler.main.TextBuffer;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
+public class GenericBoundDescriptor {
+
+  public final List<String> fparameters = new ArrayList<>();
+
+  public final List<List<VarType>> fbounds = new ArrayList<>();
+
+  private Map<VarType, List<VarType>> typeMap;
+
+  public List<VarType> getBounds(VarType key) {
+    if (typeMap == null) {
+      typeMap = new HashMap<>();
+      for (int x = 0; x < fparameters.size(); x++) {
+        typeMap.put(GenericType.parse("T" + fparameters.get(x) + ";"), fbounds.get(x));
+      }
+    }
+
+    return typeMap.get(key);
+  }
+
+  public void appendTypeParameters(TextBuffer buffer) {
+    if (fparameters.isEmpty()) {
+      return;
+    }
+
+    buffer.append('<');
+
+    for (int i = 0; i < fparameters.size(); i++) {
+      if (i > 0) {
+        buffer.append(", ");
+      }
+
+      buffer.append(fparameters.get(i));
+
+      List<VarType> parameterBounds = fbounds.get(i);
+      if (parameterBounds.size() > 1 || !"java/lang/Object".equals(parameterBounds.get(0).value)) {
+        buffer.append(" extends ");
+        buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(0)));
+        for (int j = 1; j < parameterBounds.size(); j++) {
+          buffer.append(" & ");
+          buffer.append(ExprProcessor.getCastTypeName(parameterBounds.get(j)));
+        }
+      }
+    }
+
+    buffer.append('>');
+  }
+
+  @Override
+  public String toString() {
+    TextBuffer buf = new TextBuffer();
+    buf.append("signature");
+    appendTypeParameters(buf);
+    return buf.toString();
+  }
+}
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
index 077814c..9a3373b 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericClassDescriptor.java
@@ -18,13 +18,28 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.ArrayList;
 import java.util.List;
 
-public class GenericClassDescriptor {
+import org.jetbrains.java.decompiler.main.TextBuffer;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 
-  public GenericType superclass;
+public class GenericClassDescriptor extends GenericBoundDescriptor {
 
-  public final List<GenericType> superinterfaces = new ArrayList<>();
+  public VarType superclass;
 
-  public final List<String> fparameters = new ArrayList<>();
+  public GenericType genericType;
 
-  public final List<List<GenericType>> fbounds = new ArrayList<>();
+  public final List<VarType> superinterfaces = new ArrayList<>();
+
+  @Override
+  public String toString() {
+    TextBuffer buf = new TextBuffer();
+    buf.append("signature");
+    appendTypeParameters(buf);
+    if (superclass != null) {
+      buf.append(" super ").append(superclass.toString());
+    }
+    for (VarType inf : superinterfaces) {
+      buf.append(' ').append(inf.toString());
+    }
+    return buf.toString();
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
index 598d17b..f5dd97a 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericFieldDescriptor.java
@@ -15,7 +15,13 @@
  */
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
+import org.jetbrains.java.decompiler.struct.gen.VarType;
+
 public class GenericFieldDescriptor {
+  public VarType type;
 
-  public GenericType type;
+  @Override
+  public String toString() {
+    return type == null ? "null" : type.toString();
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
index a5760a3..e915d62 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMain.java
@@ -18,6 +18,7 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import org.jetbrains.java.decompiler.code.CodeConstants;
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -35,7 +36,7 @@ public class GenericMain {
     "boolean",
   };
 
-  public static GenericClassDescriptor parseClassSignature(String signature) {
+  public static GenericClassDescriptor parseClassSignature(String qualifiedName, String signature) {
     String original = signature;
     try {
       GenericClassDescriptor descriptor = new GenericClassDescriptor();
@@ -43,15 +44,23 @@ public class GenericMain {
       signature = parseFormalParameters(signature, descriptor.fparameters, descriptor.fbounds);
 
       String superCl = GenericType.getNextType(signature);
-      descriptor.superclass = new GenericType(superCl);
+      descriptor.superclass = GenericType.parse(superCl);
 
       signature = signature.substring(superCl.length());
       while (signature.length() > 0) {
         String superIf = GenericType.getNextType(signature);
-        descriptor.superinterfaces.add(new GenericType(superIf));
+        descriptor.superinterfaces.add(GenericType.parse(superIf));
         signature = signature.substring(superIf.length());
       }
 
+      StringBuilder buf = new StringBuilder();
+      buf.append('L').append(qualifiedName).append('<');
+      for (String t : descriptor.fparameters) {
+        buf.append('T').append(t).append(';');
+      }
+      buf.append(">;");
+      descriptor.genericType = (GenericType)GenericType.parse(buf.toString());
+
       return descriptor;
     }
     catch (RuntimeException e) {
@@ -63,7 +72,7 @@ public class GenericMain {
   public static GenericFieldDescriptor parseFieldSignature(String signature) {
     try {
       GenericFieldDescriptor descriptor = new GenericFieldDescriptor();
-      descriptor.type = new GenericType(signature);
+      descriptor.type = GenericType.parse(signature);
       return descriptor;
     }
     catch (RuntimeException e) {
@@ -85,19 +94,19 @@ public class GenericMain {
 
       while (pars.length() > 0) {
         String par = GenericType.getNextType(pars);
-        descriptor.params.add(new GenericType(par));
+        descriptor.params.add(GenericType.parse(par));
         pars = pars.substring(par.length());
       }
 
       String par = GenericType.getNextType(signature);
-      descriptor.ret = new GenericType(par);
+      descriptor.ret = GenericType.parse(par);
       signature = signature.substring(par.length());
 
       if (signature.length() > 0) {
         String[] exceptions = signature.split("\\^");
 
         for (int i = 1; i < exceptions.length; i++) {
-          descriptor.exceptions.add(new GenericType(exceptions[i]));
+          descriptor.exceptions.add(GenericType.parse(exceptions[i]));
         }
       }
 
@@ -109,7 +118,7 @@ public class GenericMain {
     }
   }
 
-  private static String parseFormalParameters(String signature, List<String> parameters, List<List<GenericType>> bounds) {
+  private static String parseFormalParameters(String signature, List<String> parameters, List<List<VarType>> bounds) {
     if (signature.charAt(0) != '<') {
       return signature;
     }
@@ -142,7 +151,7 @@ public class GenericMain {
       String param = value.substring(0, to);
       value = value.substring(to + 1);
 
-      List<GenericType> lstBounds = new ArrayList<>();
+      List<VarType> lstBounds = new ArrayList<>();
 
       while (true) {
         if (value.charAt(0) == ':') {
@@ -151,7 +160,7 @@ public class GenericMain {
         }
 
         String bound = GenericType.getNextType(value);
-        lstBounds.add(new GenericType(bound));
+        lstBounds.add(GenericType.parse(bound));
         value = value.substring(bound.length());
 
 
@@ -191,69 +200,9 @@ public class GenericMain {
       return type.value;
     }
     else if (tp == CodeConstants.TYPE_OBJECT) {
-      StringBuilder buffer = new StringBuilder();
-      appendClassName(type, buffer);
-      return buffer.toString();
+      return type.getCastName();
     }
 
     throw new RuntimeException("Invalid type: " + type);
   }
-
-  private static void appendClassName(GenericType type, StringBuilder buffer) {
-    List<GenericType> enclosingClasses = type.getEnclosingClasses();
-
-    if (enclosingClasses.isEmpty()) {
-      String name = type.value.replace('/', '.');
-      buffer.append(DecompilerContext.getImportCollector().getShortName(name));
-    }
-    else {
-      for (GenericType tp : enclosingClasses) {
-        if (buffer.length() == 0) {
-          buffer.append(DecompilerContext.getImportCollector().getShortName(tp.value.replace('/', '.')));
-        }
-        else {
-          buffer.append(tp.value);
-        }
-
-        appendTypeArguments(tp, buffer);
-        buffer.append('.');
-      }
-
-      buffer.append(type.value);
-    }
-
-    appendTypeArguments(type, buffer);
-  }
-
-  private static void appendTypeArguments(GenericType type, StringBuilder buffer) {
-    if (!type.getArguments().isEmpty()) {
-      buffer.append('<');
-
-      for (int i = 0; i < type.getArguments().size(); i++) {
-        if (i > 0) {
-          buffer.append(", ");
-        }
-
-        int wildcard = type.getWildcards().get(i);
-        switch (wildcard) {
-          case GenericType.WILDCARD_UNBOUND:
-            buffer.append('?');
-            break;
-          case GenericType.WILDCARD_EXTENDS:
-            buffer.append("? extends ");
-            break;
-          case GenericType.WILDCARD_SUPER:
-            buffer.append("? super ");
-            break;
-        }
-
-        GenericType genPar = type.getArguments().get(i);
-        if (genPar != null) {
-          buffer.append(getGenericCastTypeName(genPar));
-        }
-      }
-
-      buffer.append(">");
-    }
-  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
index 2d38084..5222ad6 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericMethodDescriptor.java
@@ -18,15 +18,41 @@ package org.jetbrains.java.decompiler.struct.gen.generics;
 import java.util.ArrayList;
 import java.util.List;
 
-public class GenericMethodDescriptor {
+import org.jetbrains.java.decompiler.main.TextBuffer;
+import org.jetbrains.java.decompiler.struct.gen.VarType;
 
-  public final List<String> fparameters = new ArrayList<>();
+public class GenericMethodDescriptor extends GenericBoundDescriptor {
 
-  public final List<List<GenericType>> fbounds = new ArrayList<>();
+  public final List<VarType> params = new ArrayList<>();
 
-  public final List<GenericType> params = new ArrayList<>();
+  public VarType ret;
 
-  public GenericType ret;
+  public final List<VarType> exceptions = new ArrayList<>();
 
-  public final List<GenericType> exceptions = new ArrayList<>();
+  @Override
+  public void appendTypeParameters(TextBuffer buffer) {
+    super.appendTypeParameters(buffer);
+    if (!fparameters.isEmpty()) {
+      buffer.append(' ');
+    }
+  }
+
+  @Override
+  public String toString() {
+    TextBuffer buf = new TextBuffer();
+    buf.append("signature");
+    appendTypeParameters(buf);
+    buf.append( "(");
+    if (!params.isEmpty()) {
+      for (int x = 0; x < params.size(); x++) {
+         if (x != 0) {
+           buf.append(", ");
+         }
+         buf.append(params.get(x).toString());
+      }
+    }
+    buf.append(')');
+    buf.append(ret.toString());
+    return buf.toString();
+  }
 }
diff --git a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
index ee71f5b..81f50d5 100644
--- a/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
+++ b/src/org/jetbrains/java/decompiler/struct/gen/generics/GenericType.java
@@ -16,36 +16,49 @@
 package org.jetbrains.java.decompiler.struct.gen.generics;
 
 import org.jetbrains.java.decompiler.code.CodeConstants;
+import org.jetbrains.java.decompiler.main.DecompilerContext;
+import org.jetbrains.java.decompiler.main.extern.IFernflowerLogger.Severity;
+import org.jetbrains.java.decompiler.modules.decompiler.ExprProcessor;
+import org.jetbrains.java.decompiler.struct.StructClass;
+import org.jetbrains.java.decompiler.struct.StructContext;
 import org.jetbrains.java.decompiler.struct.gen.VarType;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
-public class GenericType {
+import javax.naming.InsufficientResourcesException;
+
+public class GenericType extends VarType {
 
   public static final int WILDCARD_EXTENDS = 1;
   public static final int WILDCARD_SUPER = 2;
   public static final int WILDCARD_UNBOUND = 3;
   public static final int WILDCARD_NO = 4;
 
-  public final int type;
-  public final int arrayDim;
-  public final String value;
+  private final VarType parent;
+  private final List<VarType> arguments;
+  private final int wildcard;
 
-  private final List<GenericType> enclosingClasses = new ArrayList<>();
-  private final List<GenericType> arguments = new ArrayList<>();
-  private final List<Integer> wildcards = new ArrayList<>();
+  public GenericType(int type, int arrayDim, String value, VarType parent, List<VarType> arguments, int wildcard) {
+    super(type, arrayDim, value, getFamily(type, arrayDim), getStackSize(type, arrayDim), false);
+    this.parent = parent;
+    this.arguments = arguments == null ? Collections.<VarType>emptyList() : arguments;
+    this.wildcard = wildcard;
+  }
 
-  public GenericType(int type, int arrayDim, String value) {
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
+  public static VarType parse(String signature) {
+    return parse(signature, WILDCARD_NO);
   }
 
-  public GenericType(String signature) {
+  public static VarType parse(String signature, int wildcard) {
     int type = 0;
     int arrayDim = 0;
     String value = null;
+    List<VarType> params = null;
+    VarType parent = null;
 
     int index = 0;
     loop:
@@ -63,32 +76,54 @@ public class GenericType {
         case 'L':
           type = CodeConstants.TYPE_OBJECT;
           signature = signature.substring(index + 1, signature.length() - 1);
+          String cl = getNextClassSignature(signature);
 
-          while (true) {
-            String cl = getNextClassSignature(signature);
-
-            String name = cl;
-            String args = null;
-
-            int argStart = cl.indexOf("<");
+          if (cl.length() == signature.length()) {
+            int argStart = cl.indexOf('<');
             if (argStart >= 0) {
-              name = cl.substring(0, argStart);
-              args = cl.substring(argStart + 1, cl.length() - 1);
-            }
-
-            if (cl.length() < signature.length()) {
-              signature = signature.substring(cl.length() + 1); // skip '.'
-              GenericType type11 = new GenericType(CodeConstants.TYPE_OBJECT, 0, name);
-              parseArgumentsList(args, type11);
-              enclosingClasses.add(type11);
+              value = cl.substring(0, argStart);
+              params = parseArgumentsList(cl.substring(argStart + 1, cl.length() - 1));
             }
             else {
-              value = name;
-              parseArgumentsList(args, this);
-              break;
+              value = cl;
+            }
+          }
+          else {
+            StringBuilder name_buff = new StringBuilder();
+            while (signature.length() > 0) {
+              String name = cl;
+              String args = null;
+
+              int argStart = cl.indexOf('<');
+              if (argStart >= 0) {
+                name = cl.substring(0, argStart);
+                args = cl.substring(argStart + 1, cl.length() - 1);
+              }
+
+              if (name_buff.length() > 0) {
+                name_buff.append('$');
+              }
+              name_buff.append(name);
+
+              value = name_buff.toString();
+              params = args == null ? null : parseArgumentsList(args);
+
+              if (cl.length() == signature.length()) {
+                break;
+              }
+              else {
+                if (parent == null && params == null) {
+                  parent = GenericType.parse("L" + value + ";");
+                }
+                else {
+                  parent = new GenericType(CodeConstants.TYPE_OBJECT, 0, value, parent, params, wildcard);
+                }
+
+                signature = signature.substring(cl.length() + 1);
+              }
+              cl = getNextClassSignature(signature);
             }
           }
-
           break loop;
 
         default:
@@ -99,9 +134,20 @@ public class GenericType {
       index++;
     }
 
-    this.type = type;
-    this.arrayDim = arrayDim;
-    this.value = value;
+    if (type == CodeConstants.TYPE_GENVAR) {
+      return new GenericType(type, arrayDim, value, null, null, wildcard);
+    }
+    else if (type == CodeConstants.TYPE_OBJECT) {
+      if (parent == null && params == null && wildcard == WILDCARD_NO) {
+        return new VarType(type, arrayDim, value);
+      }
+      else {
+        return new GenericType(type, arrayDim, value, parent, params, wildcard);
+      }
+    }
+    else {
+      return new VarType(type, arrayDim, value);
+    }
   }
 
   private static String getNextClassSignature(String value) {
@@ -129,11 +175,13 @@ public class GenericType {
     return value.substring(0, index);
   }
 
-  private static void parseArgumentsList(String value, GenericType type) {
+  private static List<VarType> parseArgumentsList(String value) {
     if (value == null) {
-      return;
+      return null;
     }
 
+    List<VarType> args = new ArrayList<VarType>();
+
     while (value.length() > 0) {
       String typeStr = getNextType(value);
       int len = typeStr.length();
@@ -151,16 +199,16 @@ public class GenericType {
           break;
       }
 
-      type.getWildcards().add(wildcard);
-
       if (wildcard != WILDCARD_NO) {
         typeStr = typeStr.substring(1);
       }
 
-      type.getArguments().add(typeStr.length() == 0 ? null : new GenericType(typeStr));
+      args.add(typeStr.length() == 0 ? null : GenericType.parse(typeStr, wildcard));
 
       value = value.substring(len);
     }
+
+    return args;
   }
 
   public static String getNextType(String value) {
@@ -211,18 +259,172 @@ public class GenericType {
 
   public GenericType decreaseArrayDim() {
     assert arrayDim > 0 : this;
-    return new GenericType(type, arrayDim - 1, value);
+    return new GenericType(type, arrayDim - 1, value, parent, arguments, wildcard);
+  }
+
+  public VarType resizeArrayDim(int newArrayDim) {
+    return new GenericType(type, newArrayDim, value, parent, arguments, wildcard);
+  }
+
+  public VarType getParent() {
+    return parent;
   }
 
-  public List<GenericType> getArguments() {
+  public List<VarType> getArguments() {
     return arguments;
   }
+  @Override
+  public boolean isGeneric() {
+    return true;
+  }
+
+  public int getWildcard() {
+    return wildcard;
+  }
 
-  public List<GenericType> getEnclosingClasses() {
-    return enclosingClasses;
+  public String getCastName() {
+    String clsName = null;
+    if (parent == null) {
+      clsName = DecompilerContext.getImportCollector().getShortName(value.replace('/', '.'));
+    }
+    else if (parent.isGeneric()) {
+      clsName = ((GenericType)parent).getCastName() + "." + value.substring(parent.value.length() + 1);
+    }
+    else {
+      clsName = DecompilerContext.getImportCollector().getShortName(parent.value.replace('/', '.')) + "." + value.substring(value.lastIndexOf('.') + 1);
+    }
+    return clsName + getTypeArguments();
   }
 
-  public List<Integer> getWildcards() {
-    return wildcards;
+  private String getTypeArguments() {
+    StringBuilder buffer = new StringBuilder();
+    if (!arguments.isEmpty()) {
+      buffer.append('<');
+
+      for (int i = 0; i < arguments.size(); i++) {
+        if (i > 0) {
+          buffer.append(", ");
+        }
+
+        VarType par = arguments.get(i);
+        if (par == null) { // Wildcard unbound
+          buffer.append('?');
+        }
+        else if (par.isGeneric()) {
+          GenericType gen = (GenericType)par;
+          switch (gen.getWildcard()) {
+            case GenericType.WILDCARD_EXTENDS:
+              buffer.append("? extends ");
+              break;
+            case GenericType.WILDCARD_SUPER:
+              buffer.append("? super ");
+              break;
+          }
+          buffer.append(GenericMain.getGenericCastTypeName(gen));
+        }
+        else {
+          buffer.append(ExprProcessor.getCastTypeName(par));
+        }
+      }
+
+      buffer.append(">");
+    }
+    return buffer.toString();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder buf = new StringBuilder();
+    switch(getWildcard()) {
+      case GenericType.WILDCARD_EXTENDS:
+        buf.append("? extends ");
+        break;
+      case GenericType.WILDCARD_SUPER:
+        buf.append("? super ");
+      break;
+    }
+    buf.append(super.toString());
+    buf.append(getTypeArguments());
+    return buf.toString();
+  }
+
+
+  @Override
+  public VarType remap(Map<VarType, VarType> map) {
+    VarType main = super.remap(map);
+    if (main != this) {
+      return main;
+    }
+    boolean changed = false;
+    VarType parent = getParent();
+    if (map.containsKey(parent)) {
+      parent = map.get(parent);
+      changed = true;
+    }
+    List<VarType> newArgs = new ArrayList<VarType>();
+    for (VarType arg : getArguments()) {
+      VarType newArg = null;
+      if (arg != null) {
+        newArg = arg.remap(map);
+      }
+      if (newArg != arg) {
+        newArgs.add(newArg);
+        changed = true;
+      } else {
+        newArgs.add(arg);
+      }
+    }
+    if (changed) {
+      return new GenericType(main.type, main.arrayDim, main.value, parent, newArgs, getWildcard());
+    }
+    return this;
+  }
+
+  // WARNING: RECURSIVE May cause depth issues, but we'll have to see
+  @Override
+  public VarType castDown(String targetAncestor) {
+    if ("java/lang/Object".equals(targetAncestor)) {
+      return VARTYPE_OBJECT;
+    }
+
+    if (this.value.equals(targetAncestor)) {
+      return this;
+    }
+
+    StructContext stCtx = DecompilerContext.getStructContext();
+    StructClass _this = stCtx.getClass(this.value);
+
+    if (_this == null) {
+      DecompilerContext.getLogger().writeMessage("Could not downcast generic object, missing current struct: " + this.toString() + " target " + targetAncestor, Severity.WARN);
+      return this;
+    }
+
+    GenericClassDescriptor desc = _this.getSignature();
+
+    if (desc == null) {
+      DecompilerContext.getLogger().writeMessage("Could not downcast generic object, missing signature in struct: " + this.toString() + " target " + targetAncestor, Severity.WARN);
+      return this;
+    }
+
+    // List<String> -> {T : String}
+    Map<VarType, VarType> map = new HashMap<>();
+    for (int x = 0; x < getArguments().size(); x++) {
+      map.put(GenericType.parse("T" + desc.fparameters.get(x) + ";"), getArguments().get(x));
+    }
+
+    for (VarType inf : desc.superinterfaces) {
+      StructClass infSt = stCtx.getClass(inf.value);
+      if (infSt == null) {
+        DecompilerContext.getLogger().writeMessage("Missing class information for downcast: " + inf.value, Severity.WARN);
+        continue;
+      }
+
+      VarType ret = (inf.isGeneric() ? inf.remap(map) : inf).castDown(targetAncestor);
+      if (ret != null) {
+        return ret;
+      }
+    }
+
+    return (desc.superclass.isGeneric() ? desc.superclass.remap(map) : desc.superclass).castDown(targetAncestor);
   }
 }
diff --git a/test/org/jetbrains/java/decompiler/SingleClassesTest.java b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
index 4fb5ebe..32185c5 100644
--- a/test/org/jetbrains/java/decompiler/SingleClassesTest.java
+++ b/test/org/jetbrains/java/decompiler/SingleClassesTest.java
@@ -25,7 +25,8 @@ public class SingleClassesTest extends SingleClassesTestBase {
   protected String[] getDecompilerOptions() {
     return new String[] {
       IFernflowerPreferences.BYTECODE_SOURCE_MAPPING, "1",
-      IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1"
+      IFernflowerPreferences.DUMP_ORIGINAL_LINES, "1",
+      IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH, "1"
     };
   }
 
@@ -85,4 +86,5 @@ public class SingleClassesTest extends SingleClassesTestBase {
   @Test public void testAccessReplace() { doTest("pkg/TestAccessReplace"); }
   @Test public void testStringLiterals() { doTest("pkg/TestStringLiterals"); }
   @Test public void testEnhancedForLoops() { doTest("pkg/TestEnhancedForLoops"); }
+  @Test public void testGenerics() { doTest("pkg/TestGenerics"); }
 }
\ No newline at end of file
diff --git a/testData/classes/pkg/TestGenerics$Child.class b/testData/classes/pkg/TestGenerics$Child.class
new file mode 100644
index 0000000000000000000000000000000000000000..39e0082b189d8bda4fc852965ad074ab7fa7edce
GIT binary patch
literal 1232
zcma)5>rN9v7(LV5(y~H9uJs0r*cPN-P&5z{LxLeGP%XjeziB&^#buXlw<P}a1$-Ax
zh}Xmi@S%)nb{AY}O!%=gJLmi6eCNB&uixK)0$9Y;9MYKS!|g1xnC-_M6b+QK1ZQ)Y
z!+ehLT>}dSDgv1m%dz}bfn>3?E09`qTS{QCYB_4Fd)QFkj%?UOhO2H<+Pl)T^f>}k
z{=U@_NU!Z%c1ytAa2(~W*|O77geR&;Z`+j})$yMz;#RXW6F4q2*q-ZZ&I5TYE4Fmn
zmAda)PMfBb<@hz~s!2~dzQANJOK76+*uSFQ9i0kW_}`_KSjY{>S8e4juac?1<<{Lp
z#eAH$z)-Oi`gMKFu58L9dSvTX+mU|PV=<P_+vBuRCb2*fqT`I5-VBo7ZXBqlugSF*
zZ%;N!{{AA`&nSDH&!{3%r#W0uqgI)#yIrrT)-B!np?C)ubjM8e!(<a1(lc=n_YFKS
z@eqp!9tn*1G(BvWfyXA6@WjLwTxIKe+@c{W^cc<(;-uMDM^8sS)}AUMY90t?DM(f$
zlqXx9$<bo05mCKMZ^&>y3={o3jnQZb7{}7?s_i`rE^b6a5wtGySjIG8QyQ!p-(Hd*
zOT*J8{(V3qKuYB=5W|UT`2@+iZ%8HZ>Ic%V32x4xAd~tEBSb$16a!of$Z*|43fnMH
z!!TYDdx;|I7^Gz?Bt{;Wc`|SlBN%1a0<B}1VBksOT1bc#hzMPH?poSBPl9_weAFv+
z%uImn2K@S_#zX#V!T<IAGcw$uMKe^mYoB!aGy2YxY{p2^5lIpu%{0Yo>RU`oCz@pa
RN*D^NSi(5>9M4mk>>s2yA0hw%

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestGenerics$Interface.class b/testData/classes/pkg/TestGenerics$Interface.class
new file mode 100644
index 0000000000000000000000000000000000000000..9ece42788f8b0bfd7749a082900f3f9c664e7ebd
GIT binary patch
literal 308
zcmZWkyN<#@3>@=F2yY}RYKqX1hKf7UAl(TG38e4?OE4jj+o0^i$5Gq|+()4^&>*Nh
zGxpfyzw6}}zzA&@H5W}nZIgxB58GX$V?x&-%=hZ7f>h}^SgiLP*$;vjCb3rblry31
z4^~Uj{Lkh1eRlFL5vpN!$|L?tQt@|IZ0t8{&XdRtZ^vA;2)*MW4xU^6nYNs7RU{to
z3D;*@ywg+}!-mj)jVsdYDu+NQ$lm~!2t|~HmxUGJ2zwwGmAm4hA+;(K5*&5M`v-~b
BOlSZA

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestGenerics$Maps.class b/testData/classes/pkg/TestGenerics$Maps.class
new file mode 100644
index 0000000000000000000000000000000000000000..a4c3dcc2e336bb973e3eac43506e0b949eca8ea9
GIT binary patch
literal 544
zcmZutO;5r=5Pb`U(u(q-h#wbCJb(v#@ni`HF`}XBfriB6Qa7+z3+adcEj^KF;t%jg
z8E1<JqHMDBX5PG+ot>}m_fG()*f)_wO~<y0jKUoqyA1i33}oD9$Tpe-2CXxF5DX<p
z2I4k(8j8^6L!X$cGxfMX;GtCUFR8_28Bx&<pAi(VgFu8GpGT3Pu<pzrN0uw1xGRX4
zUUZ~%HiH?6mn$BPDP*WMn$Cnjb1R9ZZ~f9FGWv29@Hh$S@ouYkwh;L|7+H72iSS~3
zu!3u^>eh05wmY!f>goP82|aNs)t@TM!=0!hipWE!#J_=b?9r$zKg3W@<x8Ux^;e2R
zXtaNIGN83XCtIM%B4mWQ<2l${nl{MhQ}P@p`Nf3*YuKR3KnZ1PqKXd))hT=+b3aG+
em3&$q*+u;YD&%KSrMsDWTUaMFNu{AqosA#bw0W)o

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestGenerics$Parent.class b/testData/classes/pkg/TestGenerics$Parent.class
new file mode 100644
index 0000000000000000000000000000000000000000..1af7025a9f9bd976131b0ebb97c0957d94aa8f62
GIT binary patch
literal 551
zcmZ{hO-sW-5Qg7Pn#RUxKeVk?5Cjj^gSmLJp&$i|5H!%z`!+6hYfMYB5&T)61P}fI
zf0Q`s2eg$Qc6Q!pXJ=+-e}2Ed0bJw6f{vPrBNGh<Bb15q8A{%mzi}s3GITsbErvo*
zjv}toSTIyKj@`cBYEw+!m623!2EBPPV90eQPZVABWF#Ka*P)2}d>9g`c$0vK10Ksv
zFJMkR%Y<_HJQk5+u<xTt#GQ~Qi6GwarY|F>FA~)i#AT42&m*aBZ9U)nbeZ#X+ofg4
zP1nDfKPKeS$ax%&MW9;k|A@irP0~0JcQSiHd9{(NY*;pSP%v@KP~XxhjdeEFl}dy*
zgK-9pz64;jaxiGmlc&KXk7Y&3T10MV8Za(D!9ED+*d?1M40K_WwP(J8J(Nh5*GPqw
WzDRw5LsA;5DAI1xEe&<-qwojLLV!&G

literal 0
HcmV?d00001

diff --git a/testData/classes/pkg/TestGenerics.class b/testData/classes/pkg/TestGenerics.class
new file mode 100644
index 0000000000000000000000000000000000000000..76de2f6378f2c7c8b84c962559136076785d65bd
GIT binary patch
literal 3375
zcmb7HX;Tze6g_Wdpl5~#Sp)<%xL|@Tf||I2BtTq<fD5Qm$<hoBv<yAtOpi+TeNRkc
z_EbLmEmgq^hFD4YIsYU15ve5Ryw^QFJxolMWjWpNzWeSy_nvd#48Q&J^RECN#<y{V
zFsb1w4ZC7!!P9ZX@Qj9M<0!{u1)5=Kn2I5RX$@u^6_|`-Mm}fd$DI7I;<$);c{-_K
zp#nBi6-eV!1v1FW4@W~zZeP}LMTWd27gseb%EfaUp4ae#K-tiom7EsPhi%);3?+?h
z*34>nQ6M&KJ7#9aNSGR45-2}mWK7!;h>RNPEDz3DraZW2<f3ue=*~G-vYR`-JUDL6
z+J=+Mm;!r>cl+FB(y(W{$DNF2&-Ml^gQ--~H0<7f28kw<S>+&59f&bvWgYGY!%CAE
zSAhtugL(Q@*s`fb$0YhKt6~O$4bnw9mm33_jIk(CcOiiC_|!!+AwfhgObqZ*-e=jC
z(=QNi+kS@Dq0}@BUo&Fa=2&iF%FIj{Q%PECM^XtRdB(_Ca_t!-&YVR!wIk{I+3pE5
z>l`sjgO$iKa6|Ed#dQ8qbBT8!kxUFK&^5Degn?v|`5Y@{vxA;(*q$*-VuENQYy-)x
z3-sZrk)3lHJWy&4HmH<2DV13>qX1NR$s`ZtQRZ=9#gsr}3G`MeCstb@$f+pw>Iw5H
zkPkX!$e`u9bV9w{H_)KOsyv{FQ<+0XVopFPCX}3m$`Pm>cZ|e5fhyKCyi9V651+N1
zITu?#>Ub_~W=^LG)>bNzBo{)v%3xuUq-s-X^%HC+Cs&}UZ^A26f$~oFE3rlU5=l>e
zr}_qhZk|d958R{S!OqEc_x1<S`4W$hr*fHudDxNyt_kXMhpa{CUG@m&RjA87sbeR0
z>39XNQekRSO{SVAnM}uPc%7857QNDfhBtJ)iMJ@0LR?pJgE`(+W=0@1ctFS7ct?J`
ztK&Vqui*n7AL1h&ZP-q%g{+>eHC)s2F+S1osgCRTj4bN-9AD`85?>Y7;O5fNi7tVv
zLLe7;x3mT-cKOipHNK&Jbww1)YE!Fs<2ILU_!llqFWJmrzqJKG!@QpjC&hlmZS#s(
zC)?V#Jupj!sSeMYoSpi%VQ*W>$)`F{()eQ5F&B8DrE>Cs8_Y^|pWub<usf!)K;@Pj
z>9lF{8=$K#ARX^+2&O3Fjt7hUz5M^@A9Yf02!XZv(u(KP)mSk?0WB@@CVBtW{})2u
z)s=-_a=2O2ytz0on^cp}qjXCXVF#R*Pt@|;-%#Y9r-f&<IU_q}US&jnIh^OT+iFo<
zhEGA*m}WbRz~<X?9-H~?9pbNt2%=Kr5NPKrgbuE$RDZpLYiiVA_t1;e=&yJ4r-qPo
z%g;UBJINS=&zkmI5bf3RUl6*3@Q;Z6Kw}tt`6+*`0F6w&9{c#Fy9clz2e|4jvh;B!
zaL^Aw>V>atuU>o4&<`+VOCWS*NoZ-2p=0RxLmy%yiM;G5lpR}*b_>yN^+QJJ_$VHu
za~`d08K6aA&=2_?D-P4vbsOd9Zb2LA2(KU-!X3m$mk_^=3R?Br%4Jk_E@RCys+Uny
zNL|aMz=LGqA=HtjPVyuhw#g0ZRTafH3@L`{_)F|@9Ab+ktb&)U)b%<{c&^tG)yShh
z)Jg70TB1v+y~FSE0t%O|PH4;_vp2YYUUrS=hS>_Cau)VvPIvDK?g<?8GhO3(*_2LZ
zTESX@71RribgZC3@Y-wSOQT?m*2xyJEj2gp{vpvslz7~p^iaP$*^yn;>uw*_W@a3L
zlnA4ja4szp)foR*AoLfiG#vjE8wl=%5AM1Lu4f5Nd9IpQu>O7l?jb3A31T0IXTJ|{
zTL55B2|#Hn0$A$<JV}5dHDBNJDOJ&vm(&tAD14)xUIW+hMKy5aSVz|i9th#=jk~`W
zI@o|Rp6{a~4x*L%@1&Hw$zWbtt=u_<am7&{q`V_0l*Xj8T$b~2-M!OnqwH)ILVu%1
z!x@Erqj#&EWy~l2Cig0afc2cTo2d0FxrrwKZG(g>6ya40$U6Qd(}ZdYJnV%$hx7Ca
h;R3esDd%$&hki3hdMlr;<uNkQ!r_VWUke8)_AkG<@w)&3

literal 0
HcmV?d00001

diff --git a/testData/results/TestExtendsList.dec b/testData/results/TestExtendsList.dec
index 6f116db..3f3dbea 100644
--- a/testData/results/TestExtendsList.dec
+++ b/testData/results/TestExtendsList.dec
@@ -2,11 +2,11 @@ package pkg;
 
 public class TestExtendsList {
    static <T extends Comparable<? super T>> T m1(T var0) {
-      return null;// 20
+      return (T)null;// 20
    }
 
    static <T extends Object & Comparable<? super T>> T m2(T var0) {
-      return null;// 24
+      return (T)null;// 24
    }
 }
 
diff --git a/testData/results/TestGenerics.dec b/testData/results/TestGenerics.dec
new file mode 100644
index 0000000..74bdb5e
--- /dev/null
+++ b/testData/results/TestGenerics.dec
@@ -0,0 +1,284 @@
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestGenerics<A, B extends TestGenerics.Maps & List> {
+   static Map<String, Boolean> field = TestGenerics.Maps.<String, Boolean>newHashMap();
+   static List<List<String>> llstring = new ArrayList<List<String>>();
+   static List<Byte> bytes = new ArrayList<Byte>();
+   A[] aArray = (A[])(new Object[10]);
+
+   public void genericAllocation() {
+      this.aArray = (A[])(new Object[20]);// 30
+   }// 31
+
+   public static void genericInference() {
+      HashMap<String, Integer> test = TestGenerics.Maps.<String, Integer>newHashMap();// 34
+   }// 35
+
+   public void genericList() {
+      List<B> testList = new ArrayList<B>();// 38
+      B b = testList.get(0);// 39
+      System.out.println("B:" + b);// 40
+   }// 41
+
+   public void genericCast() {
+      HashMap<String, Boolean> upcast = (HashMap<String, Boolean>)field;// 44
+   }// 45
+
+   public void genericForEach() {
+      for(String s : field.keySet()) {// 48
+         System.out.println(s);// 49
+      }
+// 51
+   }
+
+   public void genericForEachWithCast() {// 54
+      for(String s : llstring.get(0)) {// 55
+         System.out.println(s);
+      }// 57
+
+   }
+// 60
+   public <T extends Number> void genericSuperUp() {
+      List<T> list = new ArrayList<T>();// 61
+// 62
+      for(Number number : bytes) {
+         list.add(number);// 64
+      }
+
+   }
+// 79
+   public static class Child extends TestGenerics.Parent<String> implements TestGenerics.Interface<Map<String, String>> {// 80
+      Child() {// 81
+         String foo = "bar";// 82
+         this.listP.add(foo);// 83
+         TestGenerics.Parent<Integer> intP = new TestGenerics.Parent<Integer>();
+         intP.listP.add(Integer.valueOf(1));
+      }// 86
+
+      public Map<String, String> doSomething() {
+         return null;
+      }
+   }
+
+   public interface Interface<P> {
+      P doSomething();
+   }
+
+   public static class Maps {
+      public static <K, V> HashMap<K, V> newHashMap() {
+         return new HashMap<K, V>();// 68
+      }
+   }
+
+   public static class Parent<P> {
+      List<P> listP;
+   }
+}
+
+class 'pkg/TestGenerics' {
+   method 'genericAllocation ()V' {
+      0      14
+      1      14
+      2      14
+      6      14
+      7      14
+      8      14
+      9      14
+      a      14
+      b      14
+      c      15
+   }
+
+   method 'genericInference ()V' {
+      0      18
+      1      18
+      2      18
+      3      18
+      4      19
+   }
+
+   method 'genericList ()V' {
+      7      22
+      8      23
+      9      23
+      a      23
+      b      23
+      c      23
+      d      23
+      e      23
+      f      23
+      10      23
+      11      23
+      12      23
+      13      24
+      14      24
+      15      24
+      1d      24
+      1e      24
+      22      24
+      26      24
+      27      24
+      28      24
+      29      24
+      2a      24
+      2b      24
+      2c      25
+   }
+
+   method 'genericCast ()V' {
+      0      28
+      1      28
+      2      28
+      3      28
+      4      28
+      5      28
+      6      28
+      7      29
+   }
+
+   method 'genericForEach ()V' {
+      0      32
+      1      32
+      2      32
+      3      32
+      4      32
+      5      32
+      6      32
+      7      32
+      d      32
+      20      32
+      21      33
+      22      33
+      23      33
+      24      33
+      25      33
+      26      33
+      27      33
+      2b      35
+   }
+
+   method 'genericForEachWithCast ()V' {
+      0      38
+      1      38
+      2      38
+      3      38
+      4      38
+      5      38
+      6      38
+      7      38
+      8      38
+      9      38
+      a      38
+      b      38
+      11      38
+      24      38
+      25      39
+      26      39
+      27      39
+      28      39
+      29      39
+      2a      39
+      2b      39
+      2f      41
+   }
+
+   method 'genericSuperUp ()V' {
+      7      44
+      8      46
+      9      46
+      a      46
+      10      46
+      23      46
+      24      47
+      25      47
+      26      47
+      27      47
+      28      47
+      29      47
+      2a      47
+      2f      49
+   }
+}
+
+class 'pkg/TestGenerics$Child' {
+   method '<init> ()V' {
+      4      53
+      5      53
+      6      53
+      7      54
+      8      54
+      9      54
+      a      54
+      b      54
+      c      54
+      d      54
+      e      54
+      f      54
+      10      54
+      19      55
+      1a      56
+      1b      56
+      1c      56
+      1d      56
+      1e      56
+      1f      56
+      20      56
+      21      56
+      22      56
+      23      56
+      24      56
+      25      56
+      26      56
+      28      57
+   }
+
+   method 'doSomething ()Ljava/util/Map;' {
+      0      60
+      1      60
+   }
+}
+
+class 'pkg/TestGenerics$Maps' {
+   method 'newHashMap ()Ljava/util/HashMap;' {
+      7      73
+   }
+}
+
+Lines mapping:
+30 <-> 15
+31 <-> 16
+34 <-> 19
+35 <-> 20
+38 <-> 23
+39 <-> 24
+40 <-> 25
+41 <-> 26
+44 <-> 29
+45 <-> 30
+48 <-> 33
+49 <-> 34
+51 <-> 36
+54 <-> 39
+55 <-> 40
+57 <-> 42
+60 <-> 45
+61 <-> 47
+62 <-> 48
+64 <-> 50
+68 <-> 74
+79 <-> 54
+80 <-> 55
+81 <-> 56
+82 <-> 57
+83 <-> 58
+86 <-> 61
+Not mapped:
+50
+56
+63
+78
diff --git a/testData/src/pkg/TestGenerics.java b/testData/src/pkg/TestGenerics.java
new file mode 100644
index 0000000..da8de7c
--- /dev/null
+++ b/testData/src/pkg/TestGenerics.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2000-2017 JetBrains s.r.o.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package pkg;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TestGenerics<A, B extends TestGenerics.Maps & List>  {
+  static Map<String, Boolean> field = Maps.newHashMap();
+  static List<List<String>> llstring = new ArrayList<>();
+  static List<Byte> bytes = new ArrayList<>();
+  A[] aArray = (A[])(new Object[10]);
+
+  public void genericAllocation() {
+    aArray = (A[])(new Object[20]);
+  }
+  
+  public static void genericInference() {
+    HashMap<String, Integer> test = Maps.newHashMap();
+  }
+
+  public void genericList() {
+    List<B> testList = new ArrayList<B>();
+    B b = testList.get(0);
+    System.out.println("B:" + b);
+  }
+
+  public void genericCast() {
+    HashMap<String, Boolean> upcast = (HashMap<String, Boolean>)field;
+  }
+
+  public void genericForEach() { 
+    for (String s : field.keySet()) {
+      System.out.println(s);
+    }
+  }
+
+  public void genericForEachWithCast() { 
+    for (String s : llstring.get(0)) {
+      System.out.println(s);
+    }
+  }
+
+  public <T extends Number> void genericSuperUp() {
+    List<T> list = new ArrayList<>();
+    for (Number number : bytes) {
+      list.add((T)number);
+    }
+  }
+
+  public static class Maps {
+    public static <K, V> HashMap<K, V> newHashMap() {
+      return new HashMap<K, V>();
+    }
+  }
+  public static class Parent<P> {
+    List<P> listP;
+  }
+  public static interface Interface<P> {
+    P doSomething();
+  }
+  public static class Child extends Parent<String> implements Interface<Map<String, String>> {
+    Child(){
+      String foo = "bar";
+      this.listP.add(foo);
+      Parent<Integer> intP = new Parent<Integer>();
+      intP.listP.add(1);
+    }
+
+    public Map<String, String> doSomething(){
+      return null;
+    }
+  }
+}
-- 
2.11.0

